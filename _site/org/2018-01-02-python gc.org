#+BEGIN_HTML
---
layout: post
title: Python GC
---
#+END_HTML
#+OPTIONS: toc:nil
#+OPTIONS: tex:t

* 主要的 GC 算法
** 引用计数 (reference counting):
   给对象加上一个引用计数器，当对象被引用时加1，当指向这个对象的引用置空或者指向了其他对象时，引用次数减1。当引用计数为0时，自动删除这个对象。

** mark-sweep
   从寄存器和程序栈上的引用出发，遍历对象，可达的对象是还在使用的，不可达对象说明没有引用了，可以回收。

** copy-sweep
   类似 double buffer 的做法。将整个内存分成两部分，记成 A 和 B。先在 A 上分配内存，当 A 中内存耗尽时，进行垃圾回收：同样是从寄存器和栈上出发，遍历可达的对象，将可达对象复制到 B 中，然后交换 A, B 的角色。


* python 的 GC 算法
  python 的 GC 算法使用了引用计数和分代回收策略。
** 分代回收
   分代回收策略假设，存活时间越长的对象，越不可能是垃圾。大部分对象创建和释放很快，少部分对象需要长期常驻内存，所以使用不同的频率去回收这两种对象。python 将所有对象分成3代，分别是0，1，2代。如果某个对象在一次 GC 中存活下来，就加入到下一代中。

   不同代的扫描频率不同，gc 模块的 get_threshold() 表明不同代之间的扫描次数差别，例如
   #+BEGIN_SRC sh
     In [3]: gc.get_threshold()
     Out[3]: (700, 10, 10)
   #+END_SRC
   其中 700 指垃圾回收开始的阈值 (object allocation - object deallocation)，10, 10 表示，第0代每经过10次 GC 会触发一次第1代 GC，第1代每经过10次 GC 会触发一次第2代 GC。可以使用 set_threshold() 改变各代之间 GC 的比例。

** 解决循环引用
   - 循环引用发生在 container 对象中，container 对象是指内部可以持有对其他对象的引用的对象，比如 list，dict 等对象
   - 为了解决循环引用，使用有效引用计数的概念。首先将对象的引用计数复制一份。如果碰到 container 对象，递归进入 container 对象，将每个 container 对象的引用对象的有效计数减1。比如 A 引用 B, B 又引用 A，那么遍历时，B 的有效引用计数减 1，然后递归进入 A，将 A 的有效引用次数也减 1。遍历的结果是 A, B 的有效引用次数都为 0


** 回收过程
   - 对象新建的时候如果是可回收的就加入到一个可收集对象链表中
   - gc 的时候遍历可回收对象链表，同时计算有效引用计数
   - 有效引用计数为0的对象回收，有效引用计数大于0的对象移入下一代
