#+BEGIN_HTML
---
layout: post
title: 6.824 - Distributed Transactions
---
#+END_HTML
#+OPTIONS: toc:nil
#+STARTUP: latexpreview


* Topics
  - distributed transactions = distributed commit + concurrency control
  - two-phase commit
    1. prepare
    2. commit

* 什么是事务？
  - 为了应对并发的一种手段
  - 事务必须满足
    - 原子性 atomic: 所有的操作要么全部成功，要么全部失败
    - 串行化 serializable: 最终的操作像是一个一个顺序执行的
      - 一致性 consistency: 数据保持一致的状态，中间状态不会在用户端出现
      - 隔离性 isolation: 不同 transaction 之间相互不影响
    - 持久性 durable: commited 的数据经过 crash-restart 之后能恢复

* 分布式事务
  - 多台机器合作完成一个任务
  - 不同机器扮演不同角色
  - 希望可以满足原子性：要么全部 task 执行成功，要么没有 task 执行
  - 面对的挑战是：故障和性能

** two-phase commit
   - 机器角色分成两种：协调者 coordinator 和参与者 subordinate
   - 两个阶段是
     - prepare 阶段：所有参与者在 prepare 阶段达成一致，只要所有人都同意 commit 才会进入到 commit 阶段
     - commit 阶段：依据 coordinator的指示 commit or abort
   - 一个时间序
     - 假设有3台机器组成的分布式系统，coordinator 是 TC, 参与者分别是 subordinateA, subordinateB
     - client 发送事务到 subordinateA 和 subordinateB
     - client 发送事务开始信号 "go" 给 TC
     - TC 发送 "prepare" 信号给 subordinateA 和 subordinateB
     - subordinateA 和 subordinateB 做出回应
       - 如果没有 crashed, timed out 等情况，回应 "yes"
       - 否者回应 "no"
     - TC 收到回应，只要有收到 "no" 回应，发送 "abort" 消息给参与者；否者发送 "commit" 消息
     - subordinateA 和 subordinateB 响应 "abort"/"commit" 消息
   - 两阶段提交的一个问题是协调需要时间，如果有一个节点挂了或者响应慢了，所有节点要等着。消息要设置一个超时
   - 两阶段提交的终止条件：
     - coordinator 接收 "yes"/"no" 消息超时 -> abort
     - subordinate 接收 "prepare" 消息超时 -> abort
     - subordinate 接收 "commit"/"abort" 消息超时，投票是 "no" -> abort
     - subordinate 接收 "commit"/"abort" 消息超时，投票是 "yes" -> block
   - 时序图
     #+BEGIN_SRC latex :results output silent :file 2pc.png :packages '(("" "tikz")) :exports results
       \usetikzlibrary{arrows,positioning}
       \begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=5cm]
         \node (coordinator) at (0, 8) {Coordinator};
         \node (start) at(0,7) {start};
         \node (commitOrAbort1) at (0, 4) {$commit^*/abort^*$};
         \node (end) at(0, 1) {end};
         \node (subordinate) at (6, 8) {Subordinate};
         \node (prepareOrAbort) at (6, 6) {$prepare^*/abort^*$};
         \node (commitOrAbort2) at (6, 2) {$commit^*/abort^*$};

         \draw (start) edge[->] node[above, sloped]{1.PREPARE} (prepareOrAbort)
         (prepareOrAbort) edge[->] node[above, sloped]{2.VOTE YES/NO} (commitOrAbort1)
         (commitOrAbort1) edge[->] node[above, sloped]{3.COMMIT/ABORT} (commitOrAbort2)
         (commitOrAbort2) edge[->] node[above, sloped]{4.ACK}(end);
       \end{tikzpicture}
     #+END_SRC

     #+BEGIN_HTML
       <br />
       <img alt="2pc" src="/assets/img/2pc.png"/>
     #+END_HTML
     带有 * 的操作：在返回之前，先要记录日志


** 2PC 与 failure
   为了应对 crash-restart 的过程，节点在做出响应先要先记录日志，方便重新后从之前的状态中恢复
   - prepare 阶段失败
     - coordinator 发送 prepare 消息后失败 -> 不记录日志，let it crash，subordinate 投票后发现没有响应，定时来询问结果发现没有日志，回复 abort
     - coordinator 接收 prepare 响应后，发送 commit 消息前失败 -> 记录 commit 结果，restart 后重新发送 commit 消息
     - coordinator 发送 commit 消息后，接收 ack 前失败 -> 记录 ack 结果，
