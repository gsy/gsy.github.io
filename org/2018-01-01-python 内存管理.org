#+BEGIN_HTML
---
layout: post
title: Python 内存管理
---
#+END_HTML
#+OPTIONS: toc:nil
#+OPTIONS: tex:t

* python 内存管理
  python 使用内存池来管理小块内存的申请和释放，大内存使用 c 的 malloc 和 free 进行管理。

  小内存管理层级从上到下分成4级。内存池 -> arena -> pool -> block

** block
   block 是一个固定大小的内存块。申请一块小内存会返回最接近申请值大小的 block。比如申请28字节的内存，会使用32字节的 block。

** pool
   pool 是跟内存页一样大（4KB）的内存块，管理着一组 block，pool 内部 block 的大小是相同的，由 pool\_header 中 szidx 指明。
   #+BEGIN_SRC c
     /* Pool for small blocks. */
     struct pool_header {
       union { block *_padding;
         uint count; } ref;          /* number of allocated blocks    */
       block *freeblock;                   /* pool's free list head         */
       struct pool_header *nextpool;       /* next pool of this size class  */
       struct pool_header *prevpool;       /* previous pool       ""        */
       uint arenaindex;                    /* index into arenas of base adr */
       uint szidx;                         /* block size class index        */ - size class index
       uint nextoffset;                    /* bytes to virgin block         */
       uint maxnextoffset;                 /* largest valid nextoffset      */
     };
   #+END_SRC
   - 多个 pool 通过 nextpool, prevpool 指针组成双向链表
   - freeblock 组成单向链表

*** pool 中 block 的分配
    #+HEADER: :file pool_init.png :imagemagick yes
    #+HEADER: :results output silent :headers '("\\usepackage{tikz}")
    #+HEADER: :fit yes :iminoptions -density 600
    #+BEGIN_SRC latex
      \usetikzlibrary{matrix, arrows.meta, decorations.pathreplacing}
      \tikzset{
        record/.style={
          thick, rounded corners, rectangle, fill=red!30
        },
        arrow/.style={thick, >=stealth},
        array/.style={
          matrix of nodes,
          nodes in empty cells,
          thick,
          nodes={rectangle, draw=black, text centered, anchor=center, align=center, minimum width=15mm, text width=5mm, minimum height=5mm},
          column sep=-\pgflinewidth,
          row sep=-\pgflinewidth,
column 9/.style={nodes={fill=grey!50}},
column 10/.style={nodes={fill=grey!50}},
column 11/.style={nodes={fill=grey!50}},
column 12/.style={nodes={fill=grey!50}},
column 13/.style={nodes={fill=grey!50}}

        },
      }

      \begin{tikzpicture}
        \matrix[array] (pool) {
          1 &  & & & & szidx & & & & & & & \\
        };

\draw[->, {Circle[black,length=4pt]}-Latex, arrow] (pool-1-1.north west.1) to[out=20, in=160] node[above] {freeblock} (pool-1-9.north east);
\draw[->, dotted, arrow] (pool-1-7.center) to[out=-60, in=-160] node[below] {nextoffset} (pool-1-11.south west);
\draw[->, dotted, arrow] (pool-1-8.center) to[out=50, in=160] node[above] {maxnextoffset} (pool-1-12.north west);
\draw[decorate, decoration={brace,mirror, amplitude=+4mm}] (pool-1-1.south west) -- node[below=5mm] {POOL\_OVERHEAD} (pool-1-7.south east);

      \end{tikzpicture}
    #+END_SRC

    #+results:
    #+BEGIN_HTML
     <div class="figure">
     <img alt="pool_init.png" src="/assets/img/pool_init.png" />
     </div>
     #+END_HTML

    - 首次分配的 block 是 header 之后第一块可用的 block
    - freeblock 指向下一个可用的 block，供下一次分配使用
    - 如果没有 block 回收后来，freeblock 前进到 nextoffset 的位置，nextoffset 增加一个 block 的距离
    - 如果有 block 回收了，更新 freeblock，freeblock 指向回收 block 的位置，next 指针指向原来 freeblock 所在的位置，构成单链表
    - 当 nextoffset > maxnextoffset 时，整个 pool 的空间都分配完了。使用另外一个 pool 分配空间
** arena
   #+BEGIN_SRC c
     typedef uchar block;

     /* Record keeping for arenas. */
     struct arena_object {
       /* The address of the arena, as returned by malloc.  Note that 0
        ,* will never be returned by a successful malloc, and is used
        ,* here to mark an arena_object that doesn't correspond to an
        ,* allocated arena.
        ,*/
       uptr address;

       /* Pool-aligned pointer to the next pool to be carved off. */
       block* pool_address;

       /* The number of available pools in the arena:  free pools + never-
        ,* allocated pools.
        ,*/
       uint nfreepools;

       /* The total number of pools in the arena, whether or not available. */
       uint ntotalpools;

       /* Singly-linked list of available pools. */
       struct pool_header* freepools;

       /* Whenever this arena_object is not associated with an allocated
        ,* arena, the nextarena member is used to link all unassociated
        ,* arena_objects in the singly-linked `unused_arena_objects` list.
        ,* The prevarena member is unused in this case.
        ,*
        ,* When this arena_object is associated with an allocated arena
        ,* with at least one available pool, both members are used in the
        ,* doubly-linked `usable_arenas` list, which is maintained in
        ,* increasing order of `nfreepools` values.
        ,*
        ,* Else this arena_object is associated with an allocated arena
        ,* all of whose pools are in use.  `nextarena` and `prevarena`
        ,* are both meaningless in this case.
        ,*/
       struct arena_object* nextarena;
       struct arena_object* prevarena;
     };
   #+END_SRC
   - 由 nextarena, prevarena 两个指针构成双向链表
   - freepools 是指向 arena 内可以分配的 pool 的指针
   - nfreepools 表明这个 arena 里面还有多少个 pool 可供分配，如果 nfreepools == 0 则当前 arena 空间分配完了

*** arena 的状态
    #+BEGIN_SRC c
      /* The head of the singly-linked, NULL-terminated list of available
       ,* arena_objects.
       ,*/
      static struct arena_object* unused_arena_objects = NULL;

      /* The head of the doubly-linked, NULL-terminated at each end, list of
       ,* arena_objects associated with arenas that have pools available.
       ,*/
      static struct arena_object* usable_arenas = NULL;
    #+END_SRC
    arena 有两种状态
    - 未分配过 pool 的 arena 组成单链表 unused\_arena\_objects
    - arena 内有 pool 可以分配的组成双链表 usable\_arenas

*** 新建一个 arena
    #+BEGIN_SRC c
      /* Allocate a new arena.  If we run out of memory, return NULL.  Else
       ,* allocate a new arena, and return the address of an arena_object
       ,* describing the new arena.  It's expected that the caller will set
       ,* `usable_arenas` to the return value.
       ,*/
      static struct arena_object*
      new_arena(void)
      {
        struct arena_object* arenaobj;
        uint excess;        /* number of bytes above pool alignment */
        void *address;
        int err;

        if (unused_arena_objects == NULL) {
          uint i;
          uint numarenas;
          size_t nbytes;

          /* Double the number of arena objects on each allocation.
           ,* Note that it's possible for `numarenas` to overflow.
           ,*/
          numarenas = maxarenas ? maxarenas << 1 : INITIAL_ARENA_OBJECTS;
          if (numarenas <= maxarenas)
            return NULL;                /* overflow */

          ....

          nbytes = numarenas * sizeof(*arenas);
          arenaobj = (struct arena_object *)realloc(arenas, nbytes);
          if (arenaobj == NULL)
            return NULL;
          arenas = arenaobj;

          /* We might need to fix pointers that were copied.  However,
           ,* new_arena only gets called when all the pages in the
           ,* previous arenas are full.  Thus, there are *no* pointers
           ,* into the old array. Thus, we don't have to worry about
           ,* invalid pointers.  Just to be sure, some asserts:
           ,*/
          assert(usable_arenas == NULL);
          assert(unused_arena_objects == NULL);

          /* Put the new arenas on the unused_arena_objects list. */
          for (i = maxarenas; i < numarenas; ++i) {
            arenas[i].address = 0;              /* mark as unassociated */
            arenas[i].nextarena = i < numarenas - 1 ?
              &arenas[i+1] : NULL;
          }

          unused_arena_objects = &arenas[maxarenas];

          maxarenas = numarenas;
        }

        /* Take the next available arena object off the head of the list. */
        assert(unused_arena_objects != NULL);

        arenaobj = unused_arena_objects;
        unused_arena_objects = arenaobj->nextarena;

        assert(arenaobj->address == 0);
      #ifdef ARENAS_USE_MMAP
        address = mmap(NULL, ARENA_SIZE, PROT_READ|PROT_WRITE,
                       MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
        err = (address == MAP_FAILED);
      #else
        address = malloc(ARENA_SIZE);
        err = (address == 0);
      #endif
        if (err) {
          /* The allocation failed: return NULL after putting the
           ,* arenaobj back.
           ,*/
          arenaobj->nextarena = unused_arena_objects;
          unused_arena_objects = arenaobj;
          return NULL;
        }
        arenaobj->address = (uptr)address;

        ++narenas_currently_allocated;

        arenaobj->freepools = NULL;
        /* pool_address <- first pool-aligned address in the arena
           nfreepools <- number of whole pools that fit after alignment */
        arenaobj->pool_address = (block*)arenaobj->address;
        arenaobj->nfreepools = ARENA_SIZE / POOL_SIZE;

        assert(POOL_SIZE * arenaobj->nfreepools == ARENA_SIZE);

        excess = (uint)(arenaobj->address & POOL_SIZE_MASK);
        if (excess != 0) {
          --arenaobj->nfreepools;
          arenaobj->pool_address += POOL_SIZE - excess;
        }
        arenaobj->ntotalpools = arenaobj->nfreepools;

        return arenaobj;
      }
    #+END_SRC
    - 如果 unused\_arena\_objects 没有了，扩容成原来的两倍
    - freepools 指向 null
