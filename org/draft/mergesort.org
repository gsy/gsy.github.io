归并排序是一种外部排序手段，外部排序的意思是在磁盘上排序。

* 多路有序数组合并
  假设有k个数组，各自都是有序的，需要将这些数组组合成一个有序的数组。每次循环中我们需要找出k个数组中最小的一个数，从源数组中剔除，合并到结果数组的后面。假设k个数组的长度是l_1, l_2, ..., l_k，每次循环耗时为x，那么总的时间复杂度是O(l_1 + l_2 + ... + l_k) * x。x的复杂度能有多小？
** 小组赛
   k个组，两两捉对厮杀，胜利的晋级下一轮竞赛，失败的淘汰。
*** 决出冠军
    从下图来看，决出冠军需要的次数等于二叉树的边数。
    #+begin_src dot :file test.png :cmdline -Tpng :exports none :results silent
                  graph G {
                          rank=same;

                          a [label="a", shape="record"];
                          b [label="b", shape="record"];
                          c [label="c", shape="record"];
                          d [label="d", shape="record"];
                          a1 [label="a"];
                          c1 [label="c"];
                          a2 [label="a"]; 
                          
                          a1 -- a;
                          a1 -- b;
                          c1 -- c;
                          c1 -- d;
                          a2 -- a1;
                          a2 -- c1;       
                  }            
    #+end_src
    
    [[file:test.png]]

    假设二叉树的叶子节点数为L, 中间节点数为I，总的节点数为T, 则
    - 每个中间节点有两个儿子，边数为: edges = 2 * I
    - 每个节点都有一条边指向父亲，根节点除外: edges = T - 1
    - T = L + I
    综上可以推出： I=L-1，edges=2(L-1)
    n叉树也有同样的推理：(n-1)I = L-1, edges = n*I = n/n-1 * (L-1)
    所以，在有k个对的小组里决出冠军，需要2(K-1)次比赛。
*** 多路合并
    各个小组有一序列的候补选手，上一个选手成功晋级后，该序列的成员替补上继续比赛。
    #+begin_src dot :file list.png :cmdline -Tpng :exports none :results silent
      graph G {
              rank=same;

              a [label="2", shape="record"];
              b [label="3", shape="record"];
              c [label="6", shape="record"];
              d [label="9", shape="record"];

              a1 [label="a"];
              c1 [label="c"];
              a2 [label="a"];
              teama [label="{2|5|7|11|15}" ,shape="record"];
              teamb [label="{3|4}" ,shape="record"];
              teamc [label="{6|8|12|13|14}", shape="record"];
              teamd [label="{9|17|31}", shape="record"];        
              
              a1 -- a;
              a1 -- b;
              c1 -- c;
              c1 -- d;
              a2 -- a1;
              a2 -- c1;
              a -- teama;
              b -- teamb;
              c -- teamc;
              d -- teamd;     
      }
    #+end_src

    [[file:list.png]]
    

    如果进行到某组为空了，那么它的对手无条件晋级。
    可以看出，在k个数组上面建了一个最小堆，每次通过最小堆选出k个数中最小的一个，时间复杂度是O(logk)，当所有元素通过最小堆后，排序结束，总的时间复杂度是O((l_1+l_2+...+l_k)*logk)。
** 实现
   
    
   

    

