#+BEGIN_HTML
---
layout: post
title: 归并排序算法 & winner tree
---
#+END_HTML
#+OPTIONS: toc:nil
#+OPTIONS: ^:nil
归并排序是通常作为外部排序使用，如果排序文件很大，不能装载到内存里面排序，就分割成小文件，先将小文件排序，最后进行归并操作。归并排序是典型的分治算法，时间复杂度是O(nlogn)。

* 多路有序数组合并
  假设有k个数组，各自都是有序的，需要将这些数组组合成一个有序的数组。每次循环中我们需要找出k个数组中最小的一个数，从源数组中剔除，合并到结果数组的后面。假设k个数组的长度是l_1, l_2, ..., l_k，每次循环耗时为x，那么总的时间复杂度是O(l_1 + l_2 + ... + l_k) * x。x的复杂度能有多小？
** 小组赛
   k个组，两两捉对厮杀，胜利的晋级下一轮竞赛，失败的淘汰。
*** 决出冠军
    从下图来看，决出冠军需要的次数等于二叉树的边数。
    #+begin_src dot :file test.png :cmdline -Tpng :exports none :results silent
                  graph G {
                          rank=same;

                          a [label="a", shape="record"];
                          b [label="b", shape="record"];
                          c [label="c", shape="record"];
                          d [label="d", shape="record"];
                          a1 [label="a"];
                          c1 [label="c"];
                          a2 [label="a"]; 
                          
                          a1 -- a;
                          a1 -- b;
                          c1 -- c;
                          c1 -- d;
                          a2 -- a1;
                          a2 -- c1;       
                  }            
    #+end_src
    
    
[[file:test.png]]

    假设二叉树的叶子节点数为L, 中间节点数为I，总的节点数为T, 则
    - 每个中间节点有两个儿子，边数为: edges = 2 * I
    - 每个节点都有一条边指向父亲，根节点除外: edges = T - 1
    - T = L + I
    综上可以推出： I=L-1，edges=2(L-1)
    n叉树也有同样的推理：(n-1)I = L-1, edges = n*I = n/n-1 * (L-1)
    所以，在有k个对的小组里决出冠军，需要2(K-1)次比赛。
*** 多路合并
    各个小组有一序列的候补选手，上一个选手成功晋级后，该序列的成员替补上继续比赛。
    #+begin_src dot :file list.png :cmdline -Tpng :exports none :results silent
      graph G {
              rank=same;

              a [label="2", shape="record"];
              b [label="3", shape="record"];
              c [label="6", shape="record"];
              d [label="9", shape="record"];

              a1 [label="a"];
              c1 [label="c"];
              a2 [label="a"];
              teama [label="{2|5|7|11|15}" ,shape="record"];
              teamb [label="{3|4}" ,shape="record"];
              teamc [label="{6|8|12|13|14}", shape="record"];
              teamd [label="{9|17|31}", shape="record"];        
              
              a1 -- a;
              a1 -- b;
              c1 -- c;
              c1 -- d;
              a2 -- a1;
              a2 -- c1;
              a -- teama;
              b -- teamb;
              c -- teamc;
              d -- teamd;     
      }
    #+end_src

    [[file:list.png]]
    

    如果进行到某组为空了，那么它的对手无条件晋级。
    可以看出，在k个数组上面建了一个最小堆，每次通过最小堆选出k个数中最小的一个，时间复杂度是O(logk)，当所有元素通过最小堆后，排序结束，总的时间复杂度是O((l_1+l_2+...+l_k)*logk)。
** 实现
   #+BEGIN_SRC python
     # encoding: utf-8
     __author__ = 'guang'

     class Heap(object):
         def __init__(self, sources):
             """
             根据数组创建最小堆，使用list作为最小堆的数据结构
             :return:
             >>> h = Heap([[1, 3, 7, 13], [2, 6, 9], [5, 11, 13], [7, 19, 21]])
             >>> h.list
             [None, None, None, 1, 2, 5, 7]
             >>> h = Heap([])
             >>> h.list
             []
             >>> h = Heap([[1]])
             >>> h.list
             [1]
             >>> h = Heap([[1], [2]])
             >>> h.list
             [None, 1, 2]
             >>> h = Heap([[1], [2], [3]])
             >>> h.list
             [None, None, None, 1, 2, 3]
             """
             self.list = []
             self.nodes = len(sources)

             self.jobs_done = 0
             n = 0
             capacity = 2 ** n
             while capacity < self.nodes:
                 for count in range(capacity):
                     self.list.append(None)

                 n += 1
                 capacity = 2 ** n

             for ls in sources:
                 if len(ls) > 0:
                     self.list.append(ls[0])
                 else:
                     self.list.append(None)

             self.sources = []
             for source in sources:
                 g = (x for x in source)
                 self.sources.append(g)

             for g in self.sources:
                 g.next()

         def left(self, parent):
             """

             :param parent:
             :return:
             >>> h = Heap([[1], [2]])
             >>> h.left(0)
             1
             >>> h.left(1)

             >>> h.left(2)

             """
             if parent * 2 + 1 < len(self.list):
                 return self.list[parent * 2 + 1]
             else:
                 return None

         def right(self, parent):
             """
             :param parent:
             :return:
             >>> h = Heap([[1], [2]])
             >>> h.right(0)
             2
             >>> h.left(1)

             >>> h.left(2)

             """

             if parent * 2 + 2 < len(self.list):
                 return self.list[parent * 2 + 2]
             else:
                 return None

         def is_leaf(self, node):
             return node in range(self.nodes - 1, len(self.list))

         def minimum(self, left, right):
             if left is None and right is None:
                 return "None", None
             elif left is None:
                 return "right", right
             elif right is None:
                 return "left", left
             else:
                 if left < right:
                     return "left", left
                 else:
                     return "right", right

         def heapify(self):
             """
             :return:
             >>> h = Heap([[1], [2], [5], [7]])
             >>> h.heapify()

             >>> h.list
             [None, 1, 5, None, 2, None, 7]
             >>> h.heapify()
             1
             >>> h.list
             [1, 2, 5, None, None, None, 7]
             >>> h.heapify()
             2
             >>> h.list
             [2, None, 5, None, None, None, 7]
             >>> h.heapify()
             5
             >>> h.list
             [5, None, 7, None, None, None, None]
             >>> h.heapify()
             7
             >>> h.list
             [7, None, None, None, None, None, None]
             """
             def helper(node):
                 if node > len(self.list):
                     return

                 if self.is_leaf(node):
                     self.list[node] = self.get(node)
                     return

                 left = self.left(node)
                 right = self.right(node)
                 side, value = self.minimum(left, right)

                 self.list[node] = value
                 left_node = node * 2 + 1
                 right_node = node * 2 + 2

                 if side == "left":
                     helper(left_node)
                 elif side == "right":
                     helper(right_node)
                 else:
                     helper(left_node)
                     helper(right_node)

             helper(0)
             return self.list[0]

         def get(self, node):
             offset = self.nodes - 1
             index = node - offset
             already_done = []
             try:
                 return self.sources[index].next()
             except StopIteration:
                 if index not in already_done:
                     self.jobs_done += 1
                 already_done.append(index)
                 return None

         def sort(self):
             """
             :return:
             >>> sources = [[1, 3, 7, 13], [2, 6, 9], [5, 11, 13], [7, 19, 21]]
             >>> h = Heap(sources)
             >>> h.sort()
             [1, 2, 3, 5, 6, 7, 7, 9, 11, 13, 13, 19, 21]
             """
             result = []
             head = None
             while self.jobs_done < self.nodes:
                 head = self.heapify()
                 if head is not None:
                     result.append(head)

             while head is not None:
                 head = self.heapify()
                 if head is not None:
                     result.append(head)

             return result
   #+END_SRC
   
   
    
   

    

