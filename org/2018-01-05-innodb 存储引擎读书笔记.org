#+BEGIN_HTML
---
layout: post
title: Innodb 存储引擎读书笔记
---
#+END_HTML
#+OPTIONS: toc:nil
#+OPTIONS: tex:t
* innodb 的特性
  - 插入缓存 (Insert Buffer)。缓存二级索引页。因为二级缓存不是有序的，所以是随机写，为了减少磁盘的范围次数，将二级索引页缓存起来。满足以下两个条件的时候使用插入缓存
    - 索引是二级索引
    - 索引不是唯一索引
  - doublewrite buffer
    #+BEGIN_QUOTE
    The doublewrite buffer is a storage area located in the system tablespace where InnoDB writes pages that are flushed from the InnoDB buffer pool, before the pages are written to their proper positions in the data file. Only after flushing and writing pages to the doublewrite buffer, does InnoDB write pages to their proper positions. If there is an operating system, storage subsystem, or mysqld process crash in the middle of a page write, InnoDB can later find a good copy of the page from the doublewrite buffer during crash recovery.

    Although data is always written twice, the doublewrite buffer does not require twice as much I/O overhead or twice as many I/O operations. Data is written to the doublewrite buffer itself as a large sequential chunk, with a single fsync() call to the operating system.
    #+END_QUOTE
    - 从 innodb buffer pool 的内存页 flush 到磁盘文件之前，先 flush 到 doublewrite buffer. 为什么要写两次呢？
    - page 的写入不是整页一次刷到磁盘上，如果在写入的过程中发生了故障，写入的部分页数据是无效的，称之为写失效 (partial page write)
    - 失效页不能 apply redo log。所以需要先创建一个副本。
  - 自适应哈希 (adaptive hash index)
    - 根据访问的模式和频率为某些页创建 hash index
* innodb 的存储模型
  - innodb 的存储模型使用 spaces 这个概念，在 mysql 的上下文中，又称为 tablespaces
  - 一个「存储空间」(space) 由多个物理文件组成，被当成一个逻辑文件看待
  - 每个 space 有一个32位的 space id. system space 的 id 固定为 0, system space 记录的是 innodb 本身需要的一些信息
  - innodb 为每个 table 创建一个 .idb 文件
** pages
   - 一个 space 有 pages 组成，一个 page 的大小通常是 16kb，space 为每个 page 分配一个32位的 page number, 是距离 space 开头的 offset。比如，page 0 在文件中的 offset 是 0，page 1 的 offset 是 16384。
*** page overview
    #+HEADER: :file innodb_page.png :imagemagick yes
    #+HEADER: :results output silent :headers '("\\usepackage{tikz}")
    #+HEADER: :fit yes :iminoptions -density 1600
    #+BEGIN_SRC latex
     \usetikzlibrary{matrix}
     \tikzset{
       page/.style={
         matrix of nodes,
         nodes={rectangle, draw=black, minimum width=18em},
         row 2/.style={nodes={minimum height=10em}},
         row sep=-\pgflinewidth,
         column sep=-\pgflinewidth,
         nodes in empty cells
       }
     }
     \begin{tikzpicture}
       \matrix[page] (page) {
         FIL Header \\
         Other headers and page data \\
         FIL Trailer \\
       }
     \end{tikzpicture}
     #+END_SRC
    #+BEGIN_HTML
     <div class="figure">
     <img alt="innodb_page.png" src="/assets/img/innodb_page.png" />
     </div>
     #+END_HTML
*** FIL header/Trailer
    #+HEADER: :file innodb_page_header.png :imagemagick yes
    #+HEADER: :results output silent :headers '("\\usepackage{tikz}")
    #+HEADER: :fit yes :iminoptions -density 1600
    #+BEGIN_SRC latex
       \usetikzlibrary{matrix}
       \tikzset{
         page/.style={
           matrix of nodes,
           nodes={rectangle, draw=black, minimum width=18em},
         row 9/.style={nodes={minimum height=3em}},
           row sep=-\pgflinewidth,
           column sep=-\pgflinewidth,
           nodes in empty cells,
         },
       }
       \begin{tikzpicture}
         \matrix[page] (header) {
           Checksum \\
           Offset (Page Number) \\
           Previous Page \\
           Next Page \\
           LSN for last page modification \\
           Page Type \\
           Flush LSN \\
           Space ID \\
           \dots \\
           Old-Style Checksum \\
           Low 32 bits of LSN \\
         }
       \end{tikzpicture}
    #+END_SRC

     #+BEGIN_HTML
     <div class="figure">
     <img alt="page_header.png" src="/assets/img/innodb_page_header.png" />
     </div>
     #+END_HTML
     - page type 存在 header 中，表明 page data 中的数据该如果解析。不同的 page 有不同的作用，有的用于事务，有的用于索引。
     - checksum 用于校验这个 page 中的数据是不是完整的
     - previous page 和 next page 在构建 B+ 树中是有用的
     - 最后修改页的 log sequence number 记录在 header
*** system space
    #+HEADER: :file innodb_system_space.png :imagemagick yes
    #+HEADER: :results output silent :headers '("\\usepackage{tikz}")
    #+HEADER: :fit yes :iminoptions -density 1600
    #+BEGIN_SRC latex
      \usetikzlibrary{matrix}
      \tikzset{
        page/.style={
          matrix of nodes,
          nodes={rectangle, draw=black, minimum width=18em},
          row sep=-\pgflinewidth,
          column sep=-\pgflinewidth,
          nodes in empty cells,
        },
      }
      \begin{tikzpicture}
        \matrix[page] (header) {
          SYS: Insert Buffer Header \\
          Index: Insert Buffer Root \\
          TRX_SYS: Transaction System Header \\
          SYS: First Rollback System \\
          SYS: Data Directory Header \\
          More pages \dots \\
          Double Write Buffer Block \\
          More pages \dots \\
        }
      \end{tikzpicture}
    #+END_SRC

    #+BEGIN_HTML
    <div class="figure">
    <img alt="system_space.png" src="/assets/img/innodb_system_space.png" />
    </div>
    #+END_HTML

    - 记录了一些系统级别重要的空间的指针信息，比如 insert buffer, transaction system, data directory。
*** .ibd file
    #+HEADER: :file innodb_file_per_table.png :imagemagick yes
    #+HEADER: :results output silent :headers '("\\usepackage{tikz}")
    #+HEADER: :fit yes :iminoptions -density 1600
    #+BEGIN_SRC latex
      \usetikzlibrary{matrix}
      \tikzset{
        page/.style={
          matrix of nodes,
          nodes={rectangle, draw=black, minimum width=18em},
          row sep=-\pgflinewidth,
          column sep=-\pgflinewidth,
          nodes in empty cells,
        },
      }
      \begin{tikzpicture}
        \matrix[page] (header) {
          Index: root page of first index \\
          Index: root page of second index \\
          Index: node pages ... \\
          Index: leaf pages ... \\
          More pages ... \\
        }
      \end{tikzpicture}
    #+END_SRC

    #+BEGIN_HTML
    <div class="figure">
    <img alt="file_per_table.png" src="/assets/img/innodb_file_per_table.png" />
    </div>
    #+END_HTML

    - 记录聚簇索引和二级索引 root page
    - 构建 B+ 树用到的 node page 和 leaf page

* innodb 的索引
  - 每张表都有一个 primary key, 如果 create table 的时候没有创建 primary key，会使用第一个非 null 的 unique key 作为 primary key. 如果非 null 的 unique key 也没有，innodb 会创建一个隐藏48位的字段作为 primary key。所以建表的时候一定要指定 primary key, 否则隐藏字段用不上还占用6字节空间
  - 行数据以 primary key field 作为 key，其他字段以及 mvcc 用到的数据作为 value 存在一个 index structure 中。称为聚簇索引
  - 二级索引的结构跟聚簇索引的结构相同，但是 value 是指向 primary key page 的指针
  - page 里面的 record 组成单向链表，page header 中保存了 infimum record 和 supremum record 两个指针，infimum record 的 next pointer 指向这个页里面最小的记录，key 最大的记录的 next pointer 指向 supremum record
  - innodb 的索引结构是 B+ 树，B+ 树好处是当数据不能全部放到内存里面，只需要少数几次磁盘读取就可以获取到任意数据。磁盘读取的次数跟 B+ 树的高度相同，B+ 树的高度随着数据增长缓慢增高，所以 B+ 树作为索引扩展性很好
  - B+ 树开始于一个 root page, page 分成叶子页和非叶子页。叶子页存储数据，非叶子页指向其他非叶子页或者叶子页。
  - 叶子页的 record 存储 key 和对应的数据，非叶子页存储的是下一页的最小的 key 及下一页的 page number
  - 同一层的 page 组成双向链表
  - B+ 树的数据查找使用二分搜索，要判断一个 page 是否包含某个 record，要遍历 record 的单向链表，这样效率不高。在 page 底部有一个 directory 数组，将4-8个 record 当成一组，一个 directory slot 负责一组 record。这个数组是根据 record 的大小顺序排列的，可以在其中进行二分查找。
    - 从 B+树 root 节点开始查找。使用 page directory 中使用二分查找，找到一个最大值小于 search key 的 slot
    - 从找到的 slot 开始，顺着 slot 的 record 组成的单向链表线性搜索，找到一个最大值小于 search key 的 record
    - 如果是叶子页，查找结束，返回 record 结果。如果是非叶子页，将这个 record 指向的叶子页加载到内存，递归地进行搜索。

** 一颗 B+ 树
   #+HEADER: :file B_plus_tree.png :imagemagick yes
   #+HEADER: :results output silent :headers '("\\usepackage{tikz}")
   #+HEADER: :fit yes :iminoptions -density 1000
   #+BEGIN_SRC latex
     \usetikzlibrary{matrix}
     \tikzset{
       record/.style={
         thick, rounded corners, rectangle, fill=red!30
       },
       arrow/.style={thick},
       thickarraw/.style={line width=0.5mm},
       page/.style={
         matrix of nodes,
         draw=red,
         thick,
         nodes={rectangle, draw=black, text centered, align=center, minimum width=1em, text width=5em},
         column 1/.style={column sep=0.1em},
         column 3/.style={column sep=0.1em},
         row sep=1cm,
         column sep=2cm
       },
       fancytitle/.style={fill=red, text=white,rounded corners}
     }

     \newcommand{\xyshift}[3]{
       \begin{scope}[xshift=#1, yshift=#2]
         {#3}
       \end{scope}
     }
     \newcommand{\Page}[6] {
       \matrix[page, ampersand replacement=\&]({#1}) {
         \node[record](infimum) {infimum};  \&   \&  \& \node[record](supermum) {supermum}; \\
         \& {#2 \\ #3} \& {#4 \\ #5} \&  \\
       };
       \draw[->, arrow] (infimum.south) to[bend right=20] (#1-2-2.west);
       \draw[->, arrow] (#1-2-2.east) -- node[above]{next record} (#1-2-3.west);
       \draw[->, arrow] (#1-2-3.east) to[bend right=20] (supermum.south);
       \node[fancytitle, down=0.5cm] at (#1.north) ({#1-title}){#6};
     }

     \begin{tikzpicture}

       \xyshift{20cm}{10cm}{
         \Page{root}{key: \geq 0}{next page: 4}{key: \geq 4}{next page: 5}{page3}
       }
       \xyshift{7.5cm}{5cm}{
         \Page{level11}{key: \geq 0}{next page: 6}{key: \geq 2}{next page: 7}{page4}
       }
       \xyshift{36cm}{5cm}{
         \Page{level12}{key: \geq 4}{next page: 8}{key: \geq 6}{next page: 9}{page5}
       }
       \xyshift{0cm}{0cm}{
         \Page{level21}{key: 0}{value: A}{key: 1}{value: B}{page6}
       }
       \xyshift{15cm}{0cm}{
         \Page{level22}{key: 2}{value: C}{key: 3}{value: D}{page7}
       }
       \xyshift{30cm}{0cm}{
         \Page{level23}{key: 4}{value: E}{key: 5}{value: F}{page8}
       }
       \xyshift{45cm}{0cm}{
         \Page{level24}{key: 6}{value: G}{key: 7}{value: H}{page9}
       }

       \draw[->, arrow] (root-2-2.south) -- (level11-title.north);
       \draw[->, arrow] (root-2-3.south) -- (level12-title.north);

       \draw[->, arrow] (level11-2-2.south) -- (level21-title.north);
       \draw[->, arrow] (level11-2-3.south) -- (level22-title.north);
       \draw[->, arrow] (level12-2-2.south) -- (level23-title.north);
       \draw[->, arrow] (level12-2-3.south) -- (level24-title.north);

       \draw[->, thickarraw, transform canvas={yshift=2em}] (level11.east) -- node[above]{next page} (level12.west);
       \draw[->, thickarraw, transform canvas={yshift=2em}] (level21.east) -- node[above]{next page} (level22.west);
       \draw[->, thickarraw, transform canvas={yshift=2em}] (level22.east) -- node[above]{next page} (level23.west);
       \draw[->, thickarraw, transform canvas={yshift=2em}] (level23.east) -- node[above]{next page} (level24.west);
       \draw[->, thickarraw, extra thick, transform canvas={yshift=-2em}] (level12.west) -- node[below]{prev page} (level11.east);
       \draw[->, thickarraw, extra thick, transform canvas={yshift=-2em}] (level22.west) -- node[below]{prev page} (level21.east);
       \draw[->, thickarraw, extra thick, transform canvas={yshift=-2em}] (level23.west) -- node[below]{prev page} (level22.east);
       \draw[->, thickarraw, transform canvas={yshift=-2em}] (level24.west) -- node[below]{prev page} (level23.east);
     \end{tikzpicture}
   #+END_SRC

   #+BEGIN_HTML
   <div class="figure">
    <img alt="file_per_table.png" src="/assets/img/B_plus_tree.png" />
    </div>
   #+END_HTML

* innodb 的 undo log
  innodb 实现了 mvcc，不同的用户能看到不同的数据版本。mvcc 是通过 undo log 和 history system 实现的
** undo log
   - 当有记录被修改的时候，创建一条 undo log，记录当前 record 的内容
   - record 的多次修改组成链表。例如：
     #+HEADER: :file undo_log.png :imagemagick yes
     #+HEADER: :results output silent :headers '("\\usepackage{tikz}")
     #+HEADER: :fit yes :iminoptions -density 1600
     #+BEGIN_SRC latex
      \usetikzlibrary{matrix}
      \tikzset{
        log/.style={
          matrix of nodes,
          nodes={rectangle, draw, text centered, anchor=center, align=center,  minimum height=2cm, minimum width=1.5cm},
          row sep=1cm,
          column sep=1cm
        }
      }

      \begin{tikzpicture}
        \matrix[log] (log) {
          \node (log3) {Record \\ TRX\_ID = 3 \\ id = 1 \\ a = "C"};  &
          \node (log2) {Undo Update \\ TRX\_ID = 2 \\ id = 1 \\ a = "B"}; &
          \node (log1) {Undo Update \\ TRX\_ID = 1 \\ id = 1 \\ a = "A"}; &
          \node (log0) {Undo Insert \\ id = 1}; \\
        };
        \draw[->] (log3.east) -- (log2.west);
        \draw[->] (log2.east) -- (log1.west);
        \draw[->] (log1.east) -- (log0.west);
      \end{tikzpicture}
    #+END_SRC
     #+BEGIN_HTML
     <div class="figure">
     <img alt="" src="/assets/img/undo_log.png" />
     </div>
     #+END_HTML

   - 事务在修改数据的时候，是真的改动了 record 记录的内容。但是不同的事务能看到不同的视图。为了实现这点，事务在读取 record 之后，要先 revert 到这个事务允许看到的版本
   - record 维护了2个跟 undo log 有关的字段
     - DB\_TRX\_ID: 最近一个 update 或者 insert record 的事务 id
     - DB\_ROLL\_PTR: 指向 undo log record
   - 当有一个事务删除数据时，并不能物理上删除。因为其他的事务可能还在旧版本里面读。所以先标记成 delete，后台执行 purge 进程负责删除这些数据
   - purge 进程主要完成两件事情
     - 真·删除标记为要删除的 record
     - 回收 undo log 页
   - 回滚版本是有开销的，所以长期执行的 transaction 和 query 对性能是有影响的，表现在两个方面：
     - 读取变慢，因为读取完数据之后，还用 apply undo log 恢复到很早期的版本
     - 阻碍 purge 进程清理数据，导致 undo log 数据增长。
   - 二级索引的更新是标记删除，然后创建新纪录。删除是标记删除，等待 purge 进程执行。

* innodb 的事务与锁
** 事务的作用
   事务是为了实现一组操作同时进行，保证满足 ACID 4个性质：
   - 原子性 (atomicity): 一组操作全部成功或者全部失败
   - 一致性 (consistency): 从一个一致的状态出发，转换为下一个一致的状态
   - 隔离性 (isolation): 一个事务在提交前，所做的修改对其他事务不可见
   - 持久性 (durability): 数据能在经历宕机等故障之后恢复

** 事务的实现
   - 隔离性通过锁来实现
   - 持久性，正常状况下，将数据保存到磁盘保证持久性。问题是，在宕机时刻操作的数据怎么样保证也是持久化的？
     - 修改数据的操作先生成一条 log, 在事务提交的时候，将 log 的数据刷到磁盘上。
     - 数据修改的内容写入磁盘，这步不一定发生在 commit 的时候，也就是说是异步的。
     - 在修改数据之前先记录日志的方法称为 Write-Ahead Logging (WAL)
   - 原子性怎么保证？
     - 正常的操作记录到 redo log 中，将一个相反的操作记录到 undo log 中
     - 如果事务需要回滚，按照相反的顺序执行 undo log 中的 command

** 事务的隔离级别
   - READ UNCOMMITTED
   - READ COMMITTED
   - REPEATABLE READ: innodb 的默认隔离级别
   - SERIALIZABLE： 分布式事务一定要设置到这个级别(为什么？)

** 隔离级别和锁
   用例子说明。假设有表结构及测试数据
   #+BEGIN_SRC sql
     CREATE TABLE `t` (
     `a` int(11) NOT NULL DEFAULT '0',
     PRIMARY KEY (`a`)
     ) ENGINE=InnoDB DEFAULT CHARSET=utf8;

     insert into table t insert 1;
     insert into table t insert 2;
     insert into table t insert 3;
     insert into table t insert 7;
     insert into table t insert 8;
   #+END_SRC
   - 时间序示意图
     #+HEADER: :file tx_isolation_lock.png :imagemagick yes
     #+HEADER: :results output silent :headers '("\\usepackage{tikz}")
     #+HEADER: :fit yes :iminoptions -density 600 :imoutoptions -geometry 2000
     #+BEGIN_SRC latex
       \usetikzlibrary{matrix}
       \begin{tikzpicture}
         \tikzset{
           array/.style={
             matrix of nodes,
             nodes in empty cells,
             nodes={anchor=center, text centered, align=left, text width=10cm, minimum width=1.5cm, minimum height=0.5cm},
             column 1/.style={nodes={anchor=center, text width=5cm, text centered}}
           },
           line/.style={
             dashed
           },
           annotation/.style={
             circle, draw, red!80
           }
         }
         \matrix (m) [array] {
           time  & session A & session B \\
           & begin; & \\
           & select * from t where a = 1; & \\
           &        &  begin; \\
           &        &  update t set a = 10 where a = 1; \\
           & select * from t where a = 1; & \\
           &  &  commit; \\
           & select * from t where a = 1; & \\
         };
         \draw[->] (m-2-1) -- (m-8-1);
         \node [annotation, above] at (m-3-2.south) {1};
         \node [annotation, above] at (m-6-2.south) {2};
         \node [annotation, above] at (m-8-2.south) {3};

       \end{tikzpicture}
     #+END_SRC

     #+BEGIN_HTML
     <div class="figure">
     <img alt="" src="/assets/img/tx_isolation_lock.png" />
     </div>
     #+END_HTML


   - 开启两个 session。sessionA 查询 id=1 的数据，sessionB 修改 id=1 的数据
     - READ-COMMITED 级别下，sessionB commit 之后，sessionA 可以读到 sessionB 修改的数据。在上图的时间点2处，sessionA 仍能读到 a=1 的记录，到时间点3时，查询结果是空集。
     - REPEATABLE-READ 级别下，事务的多次读取读到的是同样的数据。时间点1，2，3都能读到 a=1 的记录

** 锁的类型
   - 共享锁 (share lock, S 锁)，允许事务读取一行数据
   - 排它锁 (exclude lock, X 锁)，允许事务删除或者更新一行数据
   - 意向锁

** 锁的算法
   - Record Lock: 单个行记录上的锁
   - Gap Lock: 间隙锁，锁住一个范围，但不包含记录本身
   - Next Key Lock: Gap Lock + Record Lock，锁住一个范围及记录。RR 隔离级别下默认使用这种锁算法。
   - Next Key Lock 的一个例子
     #+HEADER: :file next_key_lock.png :imagemagick yes
     #+HEADER: :results output silent :headers '("\\usepackage{tikz}")
     #+HEADER: :fit yes :iminoptions -density 600 :imoutoptions -geometry 2000
     #+BEGIN_SRC latex
       \usetikzlibrary{matrix}
       \begin{tikzpicture}
         \tikzset{
           array/.style={
             matrix of nodes,
             nodes in empty cells,
             nodes={anchor=center, text centered, align=left, text width=10cm, minimum width=1.5cm, minimum height=0.5cm},
             column 1/.style={nodes={anchor=center, text width=5cm, text centered}}
           },
           line/.style={
             dashed
           },
           annotation/.style={
             circle, draw, red!80
           }
         }
         \matrix (m) [array] {
           time  & session A & session B \\
           & begin; & \\
           & select * from t where a < 1 lock in share mode; & \\
           &        &  begin; \\
           &        &  insert into t select 5; \\
           &  commit      &   \\
         };
         \draw[->] (m-2-1) -- (m-5-1);
         \node [annotation, above] at (m-5-3.south) {1};
         \node [annotation, above] at (m-6-2.south) {2};
       \end{tikzpicture}
     #+END_SRC

     #+BEGIN_HTML
     <div class="figure">
     <img alt="" src="/assets/img/next_key_lock.png" />
     </div>
     #+END_HTML

     - sessionB 在时间点1处阻塞，知道时间点2处 sessionA commit 释放锁后才能继续执行
     - 如果 sessionA 的查询是点查，那么不会锁住间隙。例如 select * from t where a = 7 只会锁住 7 这个 record
     - sessionA 读到 sessionB 提交之后的数据称为不可重复读，两次读取之间读到的数据不一致。next key lock 是用来解决不可重复读问题的。

* 引用
  - https://blog.jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/
  - 「innodb 存储引擎」
